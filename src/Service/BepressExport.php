<?php

declare(strict_types=1);

namespace App\Service;

use App\Entity\ContributorRole;
use App\Entity\Episode;
use App\Entity\Person;
use Exception;
use League\Csv\Writer;
use Soundasleep\Html2Text;
use ZipArchive;

class BepressExport extends ExportService {
    private function getAuthors(Episode $episode) : array {
        $contributions = $this->getEpisodeContributorPersonAndRoles($episode);

        $priorityRoleFilter = function (ContributorRole $contributorRole) : bool {
            foreach (['author', 'host'] as $roleName) {
                if (str_contains(mb_strtolower($contributorRole->getLabel()), $roleName)) {
                    return true;
                }
            }
            foreach (['aud', 'aut', 'hst'] as $relatorTerm) {
                if (str_contains(mb_strtolower($contributorRole->getRelatorTerm()), $relatorTerm)) {
                    return true;
                }
            }

            return false;
        };

        usort($contributions, function (array $left, array $right) use ($priorityRoleFilter) : int {
            $leftMatches = count(array_filter($left['roles'], $priorityRoleFilter)) > 0;
            $rightMatches = count(array_filter($right['roles'], $priorityRoleFilter));

            if ($leftMatches && ! $rightMatches) {
                return 1;
            }
            if ($rightMatches && ! $leftMatches) {
                return -1;
            }

            return strcasecmp($left['person']->getSortableName(), $right['person']->getSortableName());
        });

        return array_map(fn (array $item) => $item['person'], $contributions);
    }

    private function sanitizeFilename(string $string) : string {
        return preg_replace('/[^A-Za-z0-9\_]/', '', preg_replace('/[\-\s]/', '_', $string));
    }

    private function addRecordDefaults(array $record) : array {
        $result = [];
        foreach ($this->getCsvMap() as $column => $default) {
            $result[$column] = array_key_exists($column, $record) ? Html2Text::convert($record[$column] ?? '', ['ignore_errors' => true]) : $default;
        }

        return $result;
    }

    private function getCsvMap() : array {
        // column heading => default value
        return [
            // these were in original excel example
            'title' => '', // `required`
            'fulltext_url' => '', // to be filled in manually
            'keywords' => '',
            'abstract' => '',
            'author1_fname' => '', // `required`
            // 'author1_mname' => '',
            'author1_lname' => '', // `required`
            // 'author1_suffix' => '',
            // 'author1_email' => '',
            'author1_institution' => '',
            'author1_is_corporate' => 'FALSE', // need to provide default value but we are not tracking this in amplify
            'author2_fname' => '',
            'author2_mname' => '',
            'author2_lname' => '',
            'author2_suffix' => '',
            'author2_email' => '',
            'author2_institution' => '',
            'author2_is_corporate' => 'FALSE',
            'author3_fname' => '',
            'author3_mname' => '',
            'author3_lname' => '',
            'author3_suffix' => '',
            'author3_email' => '',
            'author3_institution' => '',
            'author3_is_corporate' => 'FALSE',
            'author4_fname' => '',
            'author4_mname' => '',
            'author4_lname' => '',
            'author4_suffix' => '',
            'author4_email' => '',
            'author4_institution' => '',
            'author4_is_corporate' => 'FALSE',
            // 'disciplines' => '', // fixed list, separated by `;`
            'comments' => '',
            'create_openurl' => '0',
            // 'custom_citation' => '',
            // 'department' => '',
            // 'department2' => '',
            'document_type' => '',
            'publication_date' => '1900-01-01', // `required` format: `YYYY-MM-DD`
            // 'season' => '',

            // These are extra fields from https://bepress.com/reference_guide_dc/batch-upload-export-revise/
            // 'acknowledgments' => '',
            // 'degree_name' => '',
            // 'degree_type' => '',
            // 'distribution_license' => '', // Creative Commons license
            // 'embargo_date' => '',
            // 'identifier' => '', // generated by system
            // 'latitude' => '',
            // 'longitude' => '',
            // 'multimedia_url' => '',
            // 'multimedia_format' => '',
            'rights' => '',
            'subject_area' => '',
        ];
    }

    private function getFirstName(?Person $person) : ?string {
        $names = explode(' ', $person?->getFullname() ?? '');

        return count($names) > 1 ? $names[0] : null;
    }

    private function getLastName(?Person $person) : ?string {
        $names = explode(' ', $person?->getFullname() ?? '');

        return count($names) > 0 ? $names[count($names) - 1] : null;
    }

    protected function generate() : void {
        $this->totalSteps = ($this->totalEpisodes * 3) + 10;

        // simplifying to 1 row per episode in one csv for now
        $sanitizedTitle = $this->sanitizeFilename($this->podcast->getTitle());

        $zipBatchUpload = new ZipArchive();
        if ( ! $zipBatchUpload->open("{$this->exportTmpRootDir}/{$sanitizedTitle}_files.zip", ZipArchive::CREATE)) {
            throw new Exception('There was a problem creating the zip file');
        }

        $csv = Writer::createFromPath("{$this->exportTmpRootDir}/{$sanitizedTitle}.csv", 'w+');
        // $csv->setEscape('');
        $csv->setEnclosure('"');
        $csv->setDelimiter(',');
        $header = array_keys($this->getCsvMap());
        $csv->insertOne($header);

        $zippedTotalEpisodes = 0;
        $currentEpisode = 0;
        $this->updateMessage('Starting bepress export.');
        foreach ($this->podcast->getSeasons() as $season) {
            foreach ($season->getEpisodes() as $episode) {
                $currentEpisode++;
                $audio = $episode->getAudio('audio/mpeg') ?? $episode->getAudios()[0] ?? null;
                if (null === $audio || ! $this->filesystem->exists($audio->getFile()->getRealPath())) {
                    $this->updateMessage("Skipping metadata for {$episode->getSlug()} missing audio ({$currentEpisode}/{$this->totalEpisodes})");
                    $this->updateProgress($this->stepsCompleted += 2);

                    continue;
                }
                $authors = $this->getAuthors($episode);
                if (0 === count($authors)) {
                    $this->updateMessage("Skipping metadata for {$episode->getSlug()} missing author/contributors ({$currentEpisode}/{$this->totalEpisodes})");
                    $this->updateProgress($this->stepsCompleted += 2);

                    continue;
                }
                $zippedTotalEpisodes++;
                $this->updateMessage("Generating metadata for {$episode->getSlug()} ({$currentEpisode}/{$this->totalEpisodes})");

                $author1 = $authors[0] ?? null;
                $author2 = $authors[1] ?? null;
                $author3 = $authors[2] ?? null;
                $author4 = $authors[3] ?? null;

                $recordData = $this->addRecordDefaults([
                    // title `required`
                    'title' => "{$this->podcast->getTitle()} {$episode->getSlug()}: {$episode->getTitle()}",
                    'keywords' => count($episode->getSubjects()) > 0 ? implode(', ', $episode->getSubjects()) : '',
                    'abstract' => $episode->getDescription(),

                    // author1_fname `required`
                    'author1_fname' => $this->getFirstName($author1),
                    // author1_lname `required`
                    'author1_lname' => $this->getLastName($author1),
                    'author1_institution' => $author1?->getInstitution()?->getName(),

                    'author2_fname' => $this->getFirstName($author2),
                    'author2_lname' => $this->getLastName($author2),
                    'author2_institution' => $author2?->getInstitution()?->getName(),

                    'author3_fname' => $this->getFirstName($author3),
                    'author3_lname' => $this->getLastName($author3),
                    'author3_institution' => $author3?->getInstitution()?->getName(),

                    'author4_fname' => $this->getFirstName($author4),
                    'author4_lname' => $this->getLastName($author4),
                    'author4_institution' => $author4?->getInstitution()?->getName(),

                    'comments' => $episode->getTranscript(),
                    'document_type' => 'audio',
                    // publication_date `required` (format `YYYY-MM-DD`)
                    'publication_date' => $episode->getDate()?->format('Y-m-d'),
                    'rights' => $this->podcast->getCopyright(),
                    'subject_area' => count($this->podcast->getCategories()) > 0 ? $this->podcast->getCategories()[0]->getLabel() : '',
                ]);
                $csv->insertOne($recordData);
                $zipBatchUpload->addFile($audio->getFile()->getRealPath(), "{$episode->getSlug()}.{$audio->getExtension()}");

                $this->updateProgress(++$this->stepsCompleted);
            }
        }
        $zipBatchUpload->registerProgressCallback(0.01, function ($r) use ($zippedTotalEpisodes) : void {
            // we don't know how many files there are beforehand so we approximate the increase by
            // file completion fraction multiplied by the total episodes (why we do *2 episodes steps previously)
            $percent = (int) ($r * 100);
            $this->updateMessage("Packaging files ({$percent}%)");
            $tempCurrentStep = $this->stepsCompleted + ($r * $zippedTotalEpisodes);
            $this->updateProgress((int) $tempCurrentStep);
        });
        if ( ! $zipBatchUpload->close()) {
            throw new Exception('There was a problem saving the zip file');
        }
        $this->updateProgress($this->stepsCompleted += $zippedTotalEpisodes);
    }
}
